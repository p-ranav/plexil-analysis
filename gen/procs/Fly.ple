// PLEXIL plan for flying an AOS-based drone.  See the following wikis for
// detailed documentation:
//
//  https://babelfish.arc.nasa.gov/confluence/display/AOS/AOS+Flight+Model
//  https://babelfish.arc.nasa.gov/confluence/display/AOS/AOS+PLEXIL+Application
//
// PLEXIL implements the flight algorithm at a high level.  Supporting data
// structures and manipulation take place in a C++ based flight model.  The
// Lookups and commands in this plan interact with this model through a PLEXIL
// interface adapter.

// This plan *begins* in en route flight, and supports only en route flight.
// Departure, approach, and arrival are not covered.  Therefore, when this plan
// is started, we assume that a flight plan and initial clearance already exist.

LibraryAction AdjustForLostComm;
LibraryAction AdjustRouteForLostComm;
LibraryAction AdjustAltitudeForLostComm;

String Lookup MessageFromATC;
Boolean Lookup DueEFC;
Boolean Lookup AtClearanceLimit;
Boolean Lookup AtFinalApproachFix;
Boolean Lookup PendingRoute; // there are new (cleared) route elements to execute
Boolean Lookup NewRouteSegment;
Boolean Lookup CurrentRouteSegmentAchieved;

Command handle_atc_message (String message);
Command command_next_route_segment();
Command adjust_altitude();
Command complete_route_segment();
Command check_flight_progress();
Command request_further_clearance();
Command handle_clearance_limit();
Command squawk (Integer transponder_code);
Command pprint (...);


Fly: Concurrence
{
  In Integer Time;
  In Boolean LostComm;
  In Boolean Continue;

  Integer RouteProcessInterval = 1;  // seconds, constant
  Integer LastTime = 0;

  Exit !Continue;
  
  HandleATC:
  // Handle messages from ATC.  This includes (as is currently limited to) the
  // acceptance and execution of clearances.
  {
    Repeat true;
    WaitForMessage:
    {
      Start isKnown (Lookup (MessageFromATC));
      // NOTE: The following command must have the side effect of making
      // MessageFromATC unknown, otherwise we have a spinning loop.
      handle_atc_message (Lookup (MessageFromATC));
    }
  }


  ProcessRoute:
  // Process the route at regular intervals.  This includes commanding the craft
  // as needed to achieve the first route element, and updating the route as
  // elements are achieved.
  {
    Repeat true;
    Iterate:
    {
      Start Time > LastTime; // iterate once per simulated clock increment
      LastTime = Time;
      if (Lookup (PendingRoute)) { // Is there anywhere left to go?
        if (Lookup (NewRouteSegment)) {  // Have we just started a new leg?
          // A new route segment calls for potential lateral and altitude
          // adjustments if contact with ATC lost.
          if (LostComm) LibraryCall AdjustForLostComm(); endif
          command_next_route_segment();
        } 
        elseif (Lookup (CurrentRouteSegmentAchieved)) {
          complete_route_segment();
        }
        else {
          check_flight_progress();
        }
        endif
        adjust_altitude();
      }
      endif
    }
  }


  HandleLostComm:
  {
    Repeat true;
    InitiateLostComm:
    {
      // For now, using a plan variable instead of Lookup for LostComm.  It's
      // TBD how radio failure will be detected in the production system.

      Start LostComm && !Lookup(AtFinalApproachFix);
      End !LostComm || Lookup(AtFinalApproachFix);

      pprint ("Initiating Lost Comms procedure at time ", Time);
      squawk(7600);
      // Perform initial route/altitude adjustment for current route segment.
      LibraryCall AdjustForLostComm();
    }
    CancelLostComm:
    {
      Start !LostComm;
      Skip Lookup(AtFinalApproachFix);
      pprint ("Terminating Lost Comms procedure at time ", Time);
      // Do we need to squawk a new code?
      // TODO: clear lost comm altitude
    }
  }

  
  HandleEFC:
  // Request further clearance as needed.
  // NOTE: does this need to be a separate process, vs part of route processing?  
  {
    Repeat true;
    RequestFurtherClearance:
    {
      // NOTE: This node needs a logical wait, otherwise it will be a spinning
      // loop when started.
      Start Lookup (DueEFC);
      request_further_clearance();
    }
  }


  HandleClearanceLimit:
  // Check if we are holding at clearance limit.
  // NOTE: does this need to be a separate process, vs part of route processing?
  {
    Repeat true;
    WaitForClearanceLimit:
    {
      Start Lookup(AtClearanceLimit);
      handle_clearance_limit();
    }
  }
}
